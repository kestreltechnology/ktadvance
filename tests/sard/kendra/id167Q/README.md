## id167Q

### Discussion: Supporting proof obligations
The safety of the array access in function1 depends on the size of the
array buf that is passed in as an argument. Since function1 is not in a
position to determine this size it must delegate the responsibility for
the safety of the array access to the caller of the function. It does so
by automatically generating the necessary conditions for safety on the
argument value and advertising these as assumptions in its api. In this
case there are two safety conditions: (1) the argument should not be
null, and (2) the size of the argument should be at least 4106 (since it
accesses index 4105).

The api assumptions generated by function1 are converted by the calling
function, main, into so-called _supporting proof obligations_ that express
the conditions applied to the actual arguments. In program id167.c the
resulting proof obligation for the second api assumption, 4106 < 10,
evaluates to false, resulting in the report of a memory safety violation.
In program id170.c both supporting proof obligations are shown valid.

Note that the violation in program 167.c is reported in main and not in
function1, although the actual buffer overflow will happen in function1.
In general a violation is placed at the highest applicable position in
the callgraph if there is a choice, because this will be the most likely
position where a correction must be made. The program position of the
actual buffer violation can be found by following the chain of assumptions
and dependent ppo's/spos's that leads to the assumption that is being
violated.

Results for id167.c:

```
 Function function1
--------------------------------------------------------------------------------
50  void function1(char * buf)
--------------------------------------------------------------------------------
Api:
  parameters:
    (char *) buf

  api assumptions
   5  not-null(buf)
      --Dependent ppo's: [2]
   14  ptr-upper-bound-deref(buf,4105,op:pluspi,typ:char)
      --Dependent ppo's: [5]
--------------------------------------------------------------------------------
Primary Proof Obligations:
--------------------------------------------------------------------------------
51  {
52    /*  BAD  */
53    buf[4105] = 'A';
--------------------------------------------------------------------------------
<S>    1     53  initialized(buf)     (safe)
                  buf is a function parameter
<A>    2     53  not-null(buf)        (safe)
                  condition not-null(buf) delegated to api
<L>    3     53  valid-mem(buf)       (safe)
                  all memory regions potentially pointed at are valid: addr_in_(buf_1_)#init
<S>    4     53  ptr-lower-bound(buf,4105,op:indexpi,typ:char) (safe)
                  add non-negative number:  value is 4105
<A>    5     53  ptr-upper-bound-deref(buf,4105,op:indexpi,typ:char) (safe)
                  condition ptr-upperbound-deref(((buf +i 4105):char) delegated to api
<S>    6     53  not-null((buf + 4105)) (safe)
                  arguments of pointer arithmetic are checked for null
<S>    7     53  valid-mem((buf + 4105)) (safe)
                  pointer arithmetic stays within memory region
<S>    8     53  lower-bound(char,(buf + 4105)) (safe)
                  result of pointer arithmetic is guaranteed to satisfy lowerbound by inductive hypothesis
<S>    9     53  upper-bound(char,(buf + 4105)) (safe)
                  result of pointer arithmetic is guaranteed to satisfy upperbound by inductive hypothesis
<S>   10     53  cast(chr('A'),from:int,to:char) (safe)
                  casting constant value 65 to char
--------------------------------------------------------------------------------

Function main
--------------------------------------------------------------------------------
56  int main(int argc, char *argv[])
--------------------------------------------------------------------------------
Api:
  parameters:
    int argc
    ((char *) *) argv
--------------------------------------------------------------------------------
Primary Proof Obligations:
--------------------------------------------------------------------------------
57  {
58    char buf[10];
59
60
61    function1(buf);
--------------------------------------------------------------------------------
<S>    1     61  valid-mem(&(buf))    (safe)
                  address of a variable is a valid memory region
<S>    2     61  lower-bound(char,&(buf)) (safe)
                  address of a variable
<S>    3     61  upper-bound(char,&(buf)) (safe)
                  address of a variable
--------------------------------------------------------------------------------
Supporting Proof Obligations:
--------------------------------------------------------------------------------
57  {
58    char buf[10];
59
60
61    function1(buf);
--------------------------------------------------------------------------------
<S>    1    5   61   not-null(&(buf)) (safe)
                        address of variable buf
<*>    2   14   61   ptr-upper-bound-deref(&(buf),4105,op:pluspi,typ:char) (violation)
                        adding 4105 to the start of an array of length 10 violates the upperbound
--------------------------------------------------------------------------------
```

Results for id170.c:
```
Function function1
--------------------------------------------------------------------------------
50  void function1(char * buf)
--------------------------------------------------------------------------------
Api:
  parameters:
    (char *) buf

  api assumptions
   5  not-null(buf)
      --Dependent ppo's: [2]
   14  ptr-upper-bound-deref(buf,9,op:pluspi,typ:char)
      --Dependent ppo's: [5]
--------------------------------------------------------------------------------
Primary Proof Obligations:
--------------------------------------------------------------------------------
51  {
52    /*  OK  */
53    buf[9] = 'A';
--------------------------------------------------------------------------------
<S>    1     53  initialized(buf)     (safe)
                  buf is a function parameter
<A>    2     53  not-null(buf)        (safe)
                  condition not-null(buf) delegated to api
<L>    3     53  valid-mem(buf)       (safe)
                  all memory regions potentially pointed at are valid: addr_in_(buf_1_)#init
<S>    4     53  ptr-lower-bound(buf,9,op:indexpi,typ:char) (safe)
                  add non-negative number:  value is 9
<A>    5     53  ptr-upper-bound-deref(buf,9,op:indexpi,typ:char) (safe)
                  condition ptr-upperbound-deref(((buf +i 9):char) delegated to api
<S>    6     53  not-null((buf + 9))  (safe)
                  arguments of pointer arithmetic are checked for null
<S>    7     53  valid-mem((buf + 9)) (safe)
                  pointer arithmetic stays within memory region
<S>    8     53  lower-bound(char,(buf + 9)) (safe)
                  result of pointer arithmetic is guaranteed to satisfy lowerbound by inductive hypothesis
<S>    9     53  upper-bound(char,(buf + 9)) (safe)
                  result of pointer arithmetic is guaranteed to satisfy upperbound by inductive hypothesis
<S>   10     53  cast(chr('A'),from:int,to:char) (safe)
                  casting constant value 65 to char
--------------------------------------------------------------------------------

Function main
--------------------------------------------------------------------------------
56  int main(int argc, char *argv[])
--------------------------------------------------------------------------------
Api:
  parameters:
    int argc
    ((char *) *) argv
--------------------------------------------------------------------------------
Primary Proof Obligations:
--------------------------------------------------------------------------------
57  {
58    char buf[10];
59
60
61    function1(buf);
--------------------------------------------------------------------------------
<S>    1     61  valid-mem(&(buf))    (safe)
                  address of a variable is a valid memory region
<S>    2     61  lower-bound(char,&(buf)) (safe)
                  address of a variable
<S>    3     61  upper-bound(char,&(buf)) (safe)
                  address of a variable
--------------------------------------------------------------------------------
Supporting Proof Obligations:
--------------------------------------------------------------------------------
57  {
58    char buf[10];
59
60
61    function1(buf);
--------------------------------------------------------------------------------
<S>    1    5   61   not-null(&(buf)) (safe)
                        address of variable buf
<S>    2   14   61   ptr-upper-bound-deref(&(buf),9,op:pluspi,typ:char) (safe)
                        adding 9 to the start of an array of length 10
--------------------------------------------------------------------------------
```						
